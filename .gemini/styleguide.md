# Gemini Copilot Code Review Style Guide

버전: 1.0 / 최종 수정일: 2025-07-30

## 개요

> [!IMPORTANT]
>
> 이 스타일 가이드는 React, TypeScript, Styled Components, Zustand, Tanstack Query를 사용하는 프로젝트의 코드 품질을 향상시키기 위해 작성되었습니다.
> 제공되는 코드를 리뷰할 때 다음 가이드라인을 참고하여 개선이 필요한 부분을 지적해주시고, 가능하다면 더 나은 코드 예시도 함께 제안해주세요.
> **모든 코드 리뷰 피드백과 설명은 한국어로 작성해주시기 바랍니다.**
> 특히 다음 사항들을 중점적으로 검토해주시면 감사하겠습니다:
>
> 1. 일반 코딩 규칙 (포맷팅, 명명 규칙, 주석, 가독성)
> 2. React 모범 사례 (컴포넌트 구조, 훅스 사용, 성능 최적화)
> 3. 스타일링 (Styled Components 집중)
> 4. Vite 관련 및 빌드 최적화
> 5. 아키텍처 및 개발 환경 지침 (FSD, TypeScript 엄격 모드, Path Alias, Git Hooks)

---

## 1. 일반 코딩 규칙 (General Coding Conventions)

### 1.1. 포맷팅 (Formatting)

- **들여쓰기 (Indentation)**: `.prettierrc` 파일에 정의된 대로 일관된 들여쓰기(스페이스 2개)를 사용합니다.
- **줄 길이 (Line Length)**: `.prettierrc` 파일에 정의된 대로 한 줄의 최대 길이는 100자를 권장합니다. 가독성을 해치지 않는 선에서 유연하게 적용합니다.
- **세미콜론 (Semi-colons)**: `.prettierrc` 파일에 정의된 대로 세미콜론을 사용하지 않습니다.
- **따옴표 (Quotes)**: `.prettierrc` 파일에 정의된 대로 작은따옴표(`'`)를 사용합니다.
- **괄호 (Brackets)**: `.prettierrc` 파일에 정의된 대로 객체 리터럴이나 배열 리터럴에서 괄호 사이에 공백을 추가합니다.
- **화살표 함수 괄호 (Arrow Function Parens)**: `.prettierrc` 파일에 정의된 대로 항상 화살표 함수의 매개변수를 괄호로 감쌉니다.
- **파일 끝 줄바꿈 (End of Line)**: `.prettierrc` 파일에 정의된 대로 LF (Line Feed)를 사용합니다.

### 1.2. 명명 규칙 (Naming Conventions)

- **컴포넌트**: 파스칼 케이스(PascalCase)를 사용합니다 (예: `MyComponent`, `UserProfile`).
- **유틸리티, 훅 등 그 외**: 카멜 케이스(camelCase)를 사용합니다 (예: `formatDate`, `useAuth`).
- **변수, 함수**: 카멜 케이스(camelCase)를 사용하며, 명확하고 의미론적이며 일관성을 유지하도록 지적해주세요 (예: `userName`, `calculateTotalPrice`).
- **상수**: 대문자 스네이크 케이스(UPPER_SNAKE_CASE)를 사용합니다 (예: `API_BASE_URL`, `MAX_ITEM_COUNT`).
- **이미지**: 디자이너와 협의하여 Figma 상 파일명과 동일하게 SVG로 관리하며, `icn_(이미지명).svg`, `bg_(이미지명).svg`, `img_(이미지명).svg` 형식을 따릅니다.

### 1.3. 주석 (Comments)

- **복잡한 로직**: 복잡한 로직이나 비즈니스 규칙에 대한 설명이 필요한 경우에만 주석을 추가하도록 권장해주세요.
- **불필요한 주석**: 불필요하거나 자명한 주석은 피하도록 안내해주세요.
- **TODO/FIXME**: `// TODO: [설명]`, `// FIXME: [설명]` 형식으로 사용하며, 가능한 경우 관련 이슈 티켓 번호를 포함합니다.

### 1.4. 가독성 (Readability)

- **매직 넘버/스트링**: 의미를 알 수 없는 숫자나 문자열(매직 넘버/스트링) 대신 명명된 상수를 사용합니다. 단, CSS에 적용된 매직 넘버는 상수화하지 않아도 괜찮습니다.
- **함수 길이**: 함수는 가능한 한 짧게 유지하여 단일 책임을 갖도록 합니다.
- **중첩 깊이**: 중첩 제어문(if, for, while 등)의 깊이는 가독성을 위해 2-3단계를 넘지 않도록 노력합니다.

---

## 2. React 모범 사례 (React Best Practices)

### 2.1. 최신 React 훅스 사용

- React 19에서 도입되거나 업데이트된 훅스(use 훅 등)를 활용하고 있는지 확인하고, 가능한 경우 리팩토링을 제안해주세요.

### 2.2. 컴포넌트 구조

- **단일 책임 원칙 (Single Responsibility Principle)**: 컴포넌트는 단일 책임 원칙을 따르도록 권장해주세요. 너무 큰 컴포넌트는 작고 재사용 가능한 컴포넌트로 분리하도록 제안해주세요.
- **프레젠테이션/컨테이너 분리**: 필요에 따라 프레젠테이션 컴포넌트(UI만 담당)와 컨테이너 컴포넌트(로직 및 데이터 fetch 담당)를 분리하는 것을 고려합니다.

### 2.3. 성능 최적화

- `memo`, `useCallback`, `useMemo`: `memo`, `useCallback`, `useMemo와` 같은 React 최적화 기법이 적절하게 사용되었는지 확인하고, 불필요한 리렌더링을 줄일 수 있는 기회를 찾아 제안해주세요.
- **가상화 (Virtualization)**: 대량의 리스트 렌더링 시 React Virtualized, React Window와 같은 라이브러리를 사용하여 성능을 최적화하는 것을 고려합니다.

### 2.4. 상태 관리

- **일관된 상태 관리 패턴**: Zustand, Tanstack-Query 등 상태 관리 패턴이 일관성 있게 사용되었는지 확인하고, 복잡한 상태 로직은 커스텀 훅으로 분리하도록 제안해주세요.
- **Zustand**: 전역 상태 관리에 Zustand를 일관성 있게 사용하도록 권장합니다. 스토어는 명확한 책임을 가지도록 분리합니다.
- **Tanstack Query**: 서버 상태 관리에 Tanstack Query를 적극 활용하여 데이터 fetching, 캐싱, 동기화, 에러 처리 등을 효율적으로 관리하도록 권장합니다. `useQuery`, `useMutation` 등의 훅을 적절히 사용합니다.

### 2.5. 에러 핸들링

- **에러 바운더리 (Error Boundaries)**: UI의 특정 부분에서 발생하는 JavaScript 에러가 전체 앱을 망가뜨리지 않도록 에러 바운더리를 구현하도록 제안해주세요.
- **비동기 에러 처리**: `try-catch` 블록을 사용하여 비동기 작업(API 호출 등)에서 발생하는 에러를 적절히 처리하도록 권장합니다. Tanstack Query 사용 시 `onError` 콜백 등을 활용합니다.

---

## 3. 스타일링

### 3.1. Styled Components의 일관된 사용

- 모든 스타일링은 Styled Components를 통해 이루어지도록 권장해주세요. 인라인 스타일이나 다른 CSS 방식의 혼용을 지양합니다.

### 3.2. 의미론적 컴포넌트명

- Styled Components로 생성된 컴포넌트의 이름은 해당 컴포넌트의 역할과 스타일을 명확히 나타내도록 명명되었는지 확인해주세요. (예: `StyledButton`, `TextWrapper`).

### 3.3. 프롭스를 통한 동적 스타일링

- 동적인 스타일이 필요한 경우, 프롭스(props)를 Styled Components 내부에서 활용하여 스타일을 조건부로 변경하도록 제안해주세요. CSS 변수를 활용한 방식도 고려해주세요.

### 3.4. 테마(Theme) 시스템 활용

- 전역적인 스타일(색상, 폰트 크기, 간격 등)은 Styled Components의 테마 시스템을 통해 관리하고 일관성 있게 사용하도록 안내해주세요. 하드코딩된 값 대신 테마 변수 사용을 권장해주세요.

### 3.5. 스타일의 재사용성

- 중복되는 스타일 코드를 발견하면 Mixin(CSS 헬퍼 함수)이나 확장(extend) 또는 공통 style 컴포넌트를 활용하여 재사용성을 높이도록 제안해주세요.

### 3.6. 가독성 있는 CSS 작성

- Styled Components 내부의 CSS는 깔끔하게 들여쓰기 되고, 논리적으로 그룹화되어 가독성이 높도록 제안해주세요.

### 3.7. 불필요한 스타일 제거

- 사용되지 않거나 중복되는 스타일 정의를 찾아서 제거하도록 제안해주세요.

---

## 4. Vite 관련 및 빌드 최적화

### 4.1. 모듈 임포트 최적화

- 불필요한 전체 라이브러리 임포트 대신 필요한 모듈만 임포트(Tree-shaking)하도록 권장하여 번들 크기를 줄이도록 제안해주세요.

### 4.2. 환경 변수 사용

- 민감한 정보나 환경별 설정은 `.env` 파일을 통해 환경 변수로 관리하도록 안내해주세요.

### 4.3. 빌드 퍼포먼스

- Vite의 설정(`vite.config.js`)에서 빌드 성능을 저하시킬 수 있는 요소를 확인하고, 최적화 방안을 제안해주세요. (예: `build.sourcemap` 설정, `plugins` 최적화 등)

---

## 5. 아키텍처 및 개발 환경 지침

### 5.1. FSD (Feature-Sliced Design) 아키텍처

- 폴더 구조: FSD의 레이어별(app, processes, pages, widgets, features, entities, shared) 폴더 구조와 각 레이어의 역할에 맞게 코드가 구성되었는지 확인하고, 벗어나는 경우 적절한 위치로 이동하도록 제안해주세요.
- 레이어 규칙: 상위 레이어가 하위 레이어를 참조하고, 동일 레이어 내에서는 자유롭게 참조 가능하며, 하위 레이어가 상위 레이어를 참조하지 않도록 지켜지는지 확인해주세요.

### 5.2. TypeScript 엄격 모드

- TypeScript의 **엄격 모드(`strict: true`)** 가 `tsconfig.json`에 설정되어 있는지 확인하고, 타입 안정성을 최대한 확보하도록 권장해주세요. 명시적인 타입 선언을 통해 예측 가능한 코드를 작성하도록 제안해주세요.

### 5.3. Path Alias (`@/_`) 사용

- `tsconfig.json`과 `vite.config.js`에 설정된 **Path Alias (`@/_`)** 를 사용하여 절대 경로 임포트를 권장합니다. 이는 코드의 가독성을 높이고 경로 수정 시 유연성을 제공합니다. 상대 경로가 너무 깊어지는 경우 절대 경로 사용을 제안해주세요.

### 5.4. Git Hooks (Husky)

- `pre-commit`, `commit-msg` 등 Git Hooks(Husky) 설정이 잘 동작하는지 확인하고, 코드 스타일 및 커밋 메시지 규칙(Commitlint)이 준수되도록 상기시켜 주세요. (예: ESLint/Prettier 검사, Commitlint 규칙 준수)

---

# 6. 기타 지침

- **충분한 근거**: 충분한 근거가 없거나 정보가 불확실한 경우, 절대 임의로 지어내지 말고 "알 수 없습니다." 또는 "잘 모르겠습니다."라고 명시해 주세요.
- **정보 검증**: 답변하기 전, 단계별로 가능한 정보를 검증하고, 모호하거나 출처가 불분명한 부분은 "확실하지 않습니다."라고 표시하세요.
- **간결한 답변**: 최종적으로 확실한 정보만 사용하여 간결한 답변을 완성하세요. 만약 추측이 불가피한 경우, "추측입니다."라고 밝혀 주세요.
- **추가 정보 요청**: 사용자의 문의가 모호하거나 추가 정보가 필요하다면, 먼저 사용자의 맥락이나 세부 정보를 더 요청하세요.
- **확인되지 않은 사실 지양**: 확인되지 않은 사실을 확신에 차서 단정 지으면 안 됩니다. 필요한 경우 근거를 함께 제시하세요.
- **출처/근거 명시**: 각 답변마다 출처나 근거가 있는 경우 해당 정보를 명시하고, 가능하면 관련 링크 또는 참고 자료 링크로 최하단에 별도로 명시해주세요.
- **자바스크립트 기본**: 프로그래밍과 관련된 내용이 있을 경우, 특별한 언급이 없는 한 자바스크립트를 기본으로 하여 답변해주세요.
- **한국어 답변**: 모든 답변은 한국어로 답변해주세요.
- **ES6+**: ES6 이상의 최신 자바스크립트를 기반으로 하되, 대부분의 브라우저에서 지원하고 있는 메서드를 중점으로 알려주세요.
- **코드 리뷰 적극 활용**: 코드 리뷰를 적극 활용하고, 유지보수성을 고려하는 코드를 중시합니다.
